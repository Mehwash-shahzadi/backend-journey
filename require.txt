90-Day Backend Engineering Roadmap
Core Assumptions
Starting Knowledge: Basic Python syntax (variables, loops, functions, lists, dictionaries)
Daily Commitment: 120 minutes (2 hours) consistently
Internet: Limited bandwidth â€” prioritize text docs over HD videos
Tools Required: VS Code, Git, Python 3.11+, PostgreSQL (local or Docker)
End Goal: Portfolio-ready backend engineer with 3 production-grade projects
13-Week Overview
Week	Theme	Milestone
1-2	Python 3 & OOP Foundations	CLI Task Manager
3-4	FastAPI Fundamentals	CRUD API with PostgreSQL
5-6	Database Layer & ORM	Multi-entity Relational API
7-8	Modular Architecture	Auth-Protected Modular App
9	Event-Driven Design	Redis Message Queue System
10-11	LLM API Integration	AI Chatbot Backend
12-13	Deployment & Capstone	Production AI Service
WEEK 1-2: Python 3 & OOP Foundations
Weekly Objective: Master modern Python syntax, type hints, OOP principles, and build a CLI task manager that uses classes, file persistence, and exception handling. By Week 2, you'll have a working project demonstrating object-oriented design.

Day 1: Python 3 Modern Syntax & Virtual Environments
Prerequisites: Basic Python knowledge (variables, loops, functions)

Where to Learn:

Python 3.11 Official Tutorial â€” Sections 1-4
Real Python: Virtual Environments
freeCodeCamp: Python for Beginners â€” First 60 minutes
120-Minute Breakdown:

0-30m: Read Python 3.11 syntax differences (match/case, improved error messages, type hints)
30-50m: Set up virtual environment (python -m venv venv), activate it, install packages
50-90m: Practice: Create a project folder, initialize venv, install requests and rich libraries
90-110m: Write a script that uses f-strings, type hints (def greet(name: str) -> str), and walrus operator
110-120m: Document setup steps in README.md
Daily Exercise: Create backend_journey/day01/ folder. Write setup_check.py that:

Prints Python version
Imports requests and rich
Uses type hints for a function that calculates factorial
Saves output to output.txt using file handling
Deliverable:

GitHub repo initialized with .gitignore (Python template)
day01/setup_check.py with type hints
README.md documenting your setup
Why It Matters: Every backend job expects virtual environments, type hints (for code clarity), and modern Python syntax. Recruiters check for clean project structure immediately.

If Behind: Watch Corey Schafer's Python Virtual Environments (10 minutes), then just complete the script without advanced features.

Day 2: Modules, Packages & Project Structure
Prerequisites: Day 1 complete

Where to Learn:

Python Modules Documentation
Real Python: Python Modules and Packages
ArjanCodes: Python Project Structure
120-Minute Breakdown:

0-25m: Read about __init__.py, relative imports, and package structure
25-50m: Watch ArjanCodes video on project organization
50-90m: Create a multi-module calculator project (utils/math_ops.py, utils/string_ops.py, main.py)
90-110m: Practice importing across modules, use if __name__ == "__main__":
110-120m: Write docstrings for each module
Daily Exercise: In day02/calculator/:

Create utils/ package with math_ops.py (add, subtract, multiply) and validators.py (check numeric input)
Create main.py that imports from utils and performs calculations
Add __init__.py to make utils a proper package
Deliverable:

day02/calculator/ with proper package structure
All modules documented with docstrings
main.py demonstrates cross-module imports
Why It Matters: Backend codebases have hundreds of files. Understanding imports and package structure separates amateurs from professionals.

If Behind: Skip the video. Just create two Python files and import one into the other using from file1 import function.

Day 3: Classes & Objects Fundamentals
Prerequisites: Day 1-2 complete

Where to Learn:

Python Classes Tutorial
Real Python: OOP in Python
Corey Schafer: OOP Playlist â€” First video
120-Minute Breakdown:

0-35m: Read about classes, __init__, instance variables, methods
35-60m: Watch Corey Schafer's OOP intro
60-100m: Build a BankAccount class with deposit, withdraw, check_balance methods
100-115m: Create multiple instances and test operations
115-120m: Push to GitHub
Daily Exercise: Create day03/bank_system.py:

BankAccount class with __init__(self, owner: str, balance: float)
Methods: deposit(amount), withdraw(amount), get_balance()
Add validation (can't withdraw more than balance)
Create 3 account instances and demonstrate operations
Deliverable:

bank_system.py with complete class implementation
Test output showing deposits/withdrawals
Git commit with message "Day 3: Bank Account OOP"
Why It Matters: Backend systems model real-world entities as classes â€” users, products, orders. OOP is fundamental to every framework including FastAPI and Django.

If Behind: Just create a simple Person class with name and age. Add a method that prints a greeting.

Day 4: Inheritance & Composition
Prerequisites: Day 3 complete

Where to Learn:

Python Inheritance Docs
Real Python: Inheritance and Composition
ArjanCodes: Composition vs Inheritance
120-Minute Breakdown:

0-30m: Read about inheritance (class Child(Parent)), super(), method overriding
30-55m: Learn composition (has-a vs is-a relationships)
55-95m: Extend Day 3's BankAccount to create SavingsAccount and CheckingAccount subclasses
95-115m: Add composition example (Account "has-a" Transaction history)
115-120m: Document design decisions
Daily Exercise: Enhance day04/bank_system_v2.py:

SavingsAccount(BankAccount) with interest calculation
CheckingAccount(BankAccount) with overdraft limit
TransactionHistory class (composition) that stores all transactions
Demonstrate inheritance and composition working together
Deliverable:

Extended bank system with inheritance hierarchy
Composition example with transaction tracking
Comments explaining when to use each pattern
Why It Matters: Real APIs have layered models (BaseUser â†’ Admin, Customer). Understanding inheritance prevents code duplication in production.

If Behind: Just create one subclass (e.g., PremiumAccount) that adds a single new method.

Day 5: Dataclasses & Type Hints
Prerequisites: Day 1-4 complete

Where to Learn:

Python Dataclasses Documentation
Real Python: Python Data Classes
mCoding: Python Type Hints
120-Minute Breakdown:

0-25m: Read about @dataclass decorator and auto-generated methods
25-50m: Learn type hints (list[str], dict[str, int], Optional[str])
50-90m: Rewrite Day 4's classes using dataclasses
90-110m: Add type hints to all functions and methods
110-120m: Run mypy static type checker (install via pip)
Daily Exercise: Create day05/typed_models.py:

Convert BankAccount to a dataclass with type hints
Add Transaction dataclass with fields: id, amount, type, timestamp
Create AccountManager with typed methods: create_account(owner: str) -> BankAccount
Validate with mypy typed_models.py
Deliverable:

All classes converted to dataclasses
Complete type annotations
mypy passing without errors
Why It Matters: Pydantic (FastAPI's validation library) is built on dataclasses and type hints. Modern Python backends require strong typing for API contracts.

If Behind: Just add @dataclass to one class and type hints to two functions.

Day 6: Exception Handling & Logging
Prerequisites: Day 1-5 complete

Where to Learn:

Python Exceptions Documentation
Real Python: Python Exceptions
Real Python: Logging in Python
120-Minute Breakdown:

0-30m: Read about try/except/finally, custom exceptions, exception hierarchy
30-55m: Learn logging module (DEBUG, INFO, WARNING, ERROR, CRITICAL)
55-95m: Add exception handling to bank system (InsufficientFundsError, InvalidAmountError)
95-115m: Replace print statements with logging
115-120m: Configure logging to file
Daily Exercise: Enhance day06/bank_with_errors.py:

Create custom exceptions: InsufficientFundsError, NegativeAmountError
Wrap withdraw/deposit in try/except blocks
Add logging for all operations (INFO for success, ERROR for failures)
Configure logger to write to bank.log
Deliverable:

Exception-safe bank system
Logging to both console and file
Demonstrate error handling with test cases
Why It Matters: Production backends never crash silently. Exception handling and logging are mandatory for debugging live systems.

If Behind: Just add one try/except block around withdraw and one logger.info() statement.

Day 7: File Handling & JSON Persistence
Prerequisites: Day 1-6 complete

Where to Learn:

Python File I/O Documentation
Real Python: Reading and Writing Files
Real Python: Working with JSON
120-Minute Breakdown:

0-25m: Read about context managers (with open()), file modes (r, w, a)
25-50m: Learn JSON serialization/deserialization
50-90m: Add save/load functionality to bank system using JSON
90-110m: Handle file not found and JSON decode errors
110-120m: Test persistence across program runs
Daily Exercise: Create day07/persistent_bank.py:

Add save_to_file(filename: str) method that serializes accounts to JSON
Add load_from_file(filename: str) class method that recreates accounts
Modify dataclasses to be JSON-serializable (convert datetime to string)
Demonstrate saving, closing program, and loading data back
Deliverable:

Bank system with JSON persistence
Error handling for file operations
Test showing data survives program restart
Why It Matters: Before databases, file-based storage is essential. Understanding serialization prepares you for API request/response handling.

If Behind: Just write one function that saves a dictionary to JSON and another that reads it back.

Day 8-9: CLI Task Manager Project (Part 1)
Prerequisites: Week 1 complete

Where to Learn:

Click Documentation â€” CLI framework
Real Python: Building CLI Applications
Review Days 1-7 concepts
120-Minute Breakdown (Each Day):

Day 8: 0-30m: Design task manager (tasks have id, title, status, created_at)
Day 8: 30-90m: Build Task dataclass, TaskManager class with add/list/complete methods
Day 8: 90-120m: Implement JSON persistence
Day 9: 0-60m: Add CLI using argparse or click (commands: add, list, complete, delete)
Day 9: 60-110m: Add filtering (show only pending/completed), sorting by date
Day 9: 110-120m: Polish error messages and logging
Daily Exercise: Build day08-09/task_manager/:

models.py: Task dataclass with proper types
manager.py: TaskManager class with CRUD operations
storage.py: JSON save/load with error handling
cli.py: Command-line interface
main.py: Entry point
Deliverable:

Fully functional CLI task manager
Commands: python main.py add "task name", list, complete 1, delete 2
All data persists to tasks.json
Comprehensive README with usage examples
Why It Matters: This project combines all Week 1 concepts. CLI tools are common in DevOps and backend tooling. Shows you can build end-to-end features.

If Behind: Build simpler version without CLI â€” just functions called directly in main.py.

Day 10-11: Advanced OOP Patterns
Prerequisites: Days 1-9 complete

Where to Learn:

Python Magic Methods
Real Python: Operator Overloading
ArjanCodes: Design Patterns Playlist â€” Strategy Pattern
120-Minute Breakdown (Each Day):

Day 10: 0-40m: Learn __str__, __repr__, __eq__, __lt__ (comparison operators)
Day 10: 40-90m: Implement magic methods for Task class (sorting, equality)
Day 10: 90-120m: Add __len__ and __getitem__ to TaskManager (make it iterable)
Day 11: 0-50m: Learn Strategy pattern (different task sorting strategies)
Day 11: 50-100m: Implement SortByDate, SortByPriority strategies
Day 11: 100-120m: Refactor TaskManager to use strategy pattern
Daily Exercise: Enhance day10-11/task_manager_v2/:

Add magic methods to Task for rich comparison and string representation
Make TaskManager support for task in manager iteration
Create sorting strategies: DateSorter, PrioritySorter (add priority field to Task)
TaskManager accepts sorter in constructor
Deliverable:

Task class with all comparison operators
Iterable TaskManager
Pluggable sorting strategies
Demo showing different sort orders
Why It Matters: Magic methods make your classes feel like built-in Python types. Design patterns like Strategy are used in FastAPI dependency injection and middleware.

If Behind: Just implement __str__ and __repr__ for Task. Skip the Strategy pattern.

Day 12-14: Week 2 Integration & Polish
Prerequisites: Days 1-11 complete

120-Minute Breakdown (Each Day):

Day 12: Add priority levels (HIGH, MEDIUM, LOW) using Enum
Day 12: Implement filtering by priority and status
Day 12: Add tags/categories to tasks
Day 13: Create export_to_csv() function
Day 13: Add task statistics (total, completed percentage, overdue)
Day 13: Improve CLI with colored output (use rich library)
Day 14: Write comprehensive README
Day 14: Clean up code, add docstrings everywhere
Day 14: Create demo video/GIF for portfolio
Daily Exercise: Final polish day12-14/task_manager_final/:

Add Enum for priority, categories
Implement export functionality
Add statistics dashboard command
Rich formatting for terminal output
Complete documentation
Deliverable:

Production-quality task manager
Professional README with screenshots
All code documented
GitHub release (v1.0.0)
Weekly Deliverables Checklist (Week 1-2):

âœ… Virtual environment setup documented
âœ… Multi-module package structure
âœ… OOP principles demonstrated (inheritance, composition, dataclasses)
âœ… Exception handling and logging throughout
âœ… JSON persistence implemented
âœ… CLI application with multiple commands
âœ… Design patterns applied (Strategy)
âœ… Professional GitHub repository with README
Why It Matters: This project goes on your portfolio. It shows OOP mastery, clean code, and ability to build complete features â€” exactly what entry-level jobs require.

If Behind: Focus on core features only (add, list, complete). Skip export and statistics.

WEEK 3-4: FastAPI Fundamentals
Weekly Objective: Master REST API development with FastAPI, including routing, request/response models with Pydantic 2.0, dependency injection, async programming, and OpenAPI documentation. Build a complete CRUD API with PostgreSQL integration.

Day 15: HTTP Basics & FastAPI Setup
Prerequisites: Python OOP knowledge from Weeks 1-2

Where to Learn:

FastAPI Official Tutorial â€” First Steps
HTTP Methods Explained
freeCodeCamp: APIs for Beginners â€” First 30 minutes
120-Minute Breakdown:

0-30m: Learn HTTP methods (GET, POST, PUT, DELETE), status codes (200, 201, 404, 500)
30-55m: Install FastAPI and Uvicorn (pip install fastapi uvicorn[standard])
55-95m: Create first FastAPI app with basic routes
95-115m: Test with browser and Postman
115-120m: Explore auto-generated docs at /docs
Daily Exercise: Create day15/first_api/:

main.py with FastAPI instance
Routes: GET / (hello world), GET /items/{item_id} (path parameter), GET /search (query parameter)
Run with uvicorn main:app --reload
Test all routes in Postman, screenshot /docs page
Deliverable:

Working FastAPI server
3+ routes demonstrating path and query parameters
Screenshots of interactive docs
Git commit "Day 15: First FastAPI app"
Why It Matters: FastAPI is the fastest-growing Python web framework (2025). Its auto-generated OpenAPI docs and type safety make it preferred for backend roles.

If Behind: Just create one GET route that returns {"message": "Hello"}. Test in browser.

Day 16: Pydantic 2.0 Models
Prerequisites: Day 15 complete

Where to Learn:

Pydantic 2.0 Documentation
FastAPI: Request Body
Pydantic Models Video â€” ArjanCodes
120-Minute Breakdown:

0-35m: Learn Pydantic BaseModel, Field validators, type coercion
35-60m: Understand request/response models separation
60-100m: Build User model with validation (email format, password length)
100-115m: Create POST routes that accept Pydantic models
115-120m: Test validation errors in Postman
Daily Exercise: Create day16/user_api/:

models.py: UserCreate (email, password, age), UserResponse (exclude password)
main.py: POST /users endpoint accepting UserCreate, returns UserResponse
Add Field validators (email regex, age > 0, password min 8 chars)
Test valid and invalid inputs
Deliverable:

Pydantic models with validation rules
POST endpoint with request/response model separation
Documentation showing validation errors
Why It Matters: Pydantic provides automatic data validation and serialization. Every production API uses request/response models to enforce contracts and prevent bad data.

If Behind: Create one simple model with 2 fields (name, age). Skip complex validators.

Day 17: CRUD Operations (In-Memory)
Prerequisites: Days 15-16 complete

Where to Learn:

FastAPI CRUD Tutorial
REST API Best Practices
Review HTTP methods from Day 15
120-Minute Breakdown:

0-25m: Plan CRUD endpoints (POST /users, GET /users, GET /users/{id}, PUT /users/{id}, DELETE /users/{id})
25-70m: Implement all CRUD operations storing users in list
70-105m: Add proper HTTP status codes (201 for create, 404 for not found)
105-115m: Handle edge cases (duplicate email, delete non-existent user)
115-120m: Test complete workflow in Postman
Daily Exercise: Build day17/crud_api/:

In-memory storage (Python list)
POST /users â†’ create user with auto-generated ID
GET /users â†’ return all users
GET /users/{id} â†’ return single user or 404
PUT /users/{id} â†’ update user
DELETE /users/{id} â†’ remove user
Handle errors with HTTPException
Deliverable:

Complete CRUD API
Proper status codes everywhere
Error handling for all edge cases
Postman collection with all requests
Why It Matters: CRUD is 80% of backend work. Mastering REST conventions makes you immediately productive in any API project.

If Behind: Just implement POST and GET all. Skip update and delete.

Day 18: Async Programming Basics
Prerequisites: Days 15-17 complete

Where to Learn:

Python Asyncio Documentation
Real Python: Async IO in Python
FastAPI: Async Concurrency
120-Minute Breakdown:

0-35m: Learn async/await, event loop, coroutines vs threads
35-60m: Understand when to use async (I/O-bound operations)
60-95m: Convert Day 17 routes to async functions
95-115m: Add simulated async operation (sleep, external API call)
115-120m: Compare performance with sync version
Daily Exercise: Create day18/async_api/:

Convert all route functions to async def
Add GET /slow endpoint with await asyncio.sleep(2) simulating database call
Add GET /external that uses httpx (async HTTP client) to fetch data from JSONPlaceholder
Demonstrate concurrent requests (multiple /slow calls complete faster together)
Deliverable:

Fully async FastAPI application
Demo showing async benefits (concurrent request handling)
Notes on when to use sync vs async
Why It Matters: Modern backends handle thousands of concurrent connections. Async programming is essential for database queries, API calls, and real-time features.

If Behind: Just convert one route to async def. Skip the external API call.

Day 19: Dependency Injection
Prerequisites: Days 15-18 complete

Where to Learn:

FastAPI Dependencies
ArjanCodes: Dependency Injection
FastAPI Advanced Dependencies
120-Minute Breakdown:

0-30m: Learn Depends() function, dependency hierarchy
30-55m: Understand separation of concerns (route logic vs business logic)
55-90m: Create reusable dependencies (get_current_user, pagination params)
90-115m: Implement pagination with skip and limit parameters
115-120m: Refactor Day 17 CRUD using dependencies
Daily Exercise: Enhance day19/di_api/:

Create dependencies.py with get_pagination() returning skip and limit
Create get_user_by_id() dependency that validates user exists
Modify GET /users to use pagination dependency
Modify PUT/DELETE /users/{id} to use user validation dependency
Demonstrate dependency reuse across routes
Deliverable:

Dependency functions separated from routes
Pagination implemented via DI
Validation logic extracted to dependencies
Cleaner route handlers
Why It Matters: Dependency injection is FastAPI's superpower. It enables testable code, shared logic, and is the foundation for database sessions and authentication.

If Behind: Just create one dependency function for pagination. Use it in one route.

Day 20: Background Tasks & Middleware
Prerequisites: Days 15-19 complete

Where to Learn:

FastAPI Background Tasks
FastAPI Middleware
Real Python: Python Logging â€” Review
120-Minute Breakdown:

0-30m: Learn BackgroundTasks for async operations (emails, logging)
30-60m: Understand middleware for cross-cutting concerns (logging, timing)
60-95m: Implement email simulation as background task
95-115m: Create request timing middleware
115-120m: Add logging middleware
Daily Exercise: Build day20/background_api/:

POST /users endpoint triggers background task (simulate email with asyncio.sleep)
Add middleware that logs request method, path, and duration
Add middleware that adds custom header to all responses
Demonstrate background task doesn't block response
Deliverable:

Background tasks implementation
2 custom middleware functions
Logs showing request timing
Proof that background tasks are non-blocking
Why It Matters: Production APIs send emails, process images, and log analytics without slowing responses. Middleware handles auth, CORS, and monitoring in real systems.

If Behind: Just implement one background task (simple logging). Skip middleware.

Day 21: PostgreSQL Setup
Prerequisites: Days 15-20 complete

Where to Learn:

PostgreSQL Official Tutorial
PostgreSQL Installation Guide
W3Schools SQL Tutorial â€” Sections 1-5
120-Minute Breakdown:

0-40m: Install PostgreSQL locally or via Docker (docker run postgres)
40-65m: Learn basic SQL (CREATE TABLE, INSERT, SELECT, WHERE, JOIN)
65-95m: Use psql or pgAdmin to create database, tables
95-115m: Practice CRUD operations in raw SQL
115-120m: Document connection details
Daily Exercise: Setup day21/postgres_practice/:

Install PostgreSQL and create database fastapi_db
Create users table (id, email, name, created_at)
Write SQL file with CREATE TABLE, INSERT 5 users, SELECT queries
Execute queries manually and save results
Document connection string (postgresql://user:pass@localhost/fastapi_db)
Deliverable:

Running PostgreSQL instance
Database and table created
SQL script with sample data
Connection details documented
Why It Matters: PostgreSQL is the most popular open-source database. Understanding SQL before ORMs makes you a better backend engineer.

If Behind: Use Docker to avoid installation issues: docker run -e POSTGRES_PASSWORD=password -p 5432:5432 postgres. Just create one table.

Day 22: SQLAlchemy ORM Basics
Prerequisites: Day 21 complete

Where to Learn:

SQLAlchemy 2.0 Documentation
FastAPI with SQLAlchemy
Pretty Printed: SQLAlchemy Tutorial
120-Minute Breakdown:

0-35m: Install SQLAlchemy and psycopg2 (pip install sqlalchemy psycopg2-binary)
35-60m: Learn ORM concepts (models, sessions, queries)
60-100m: Create User model, engine, session
100-115m: Perform CRUD via ORM (no raw SQL)
115-120m: Compare with Day 21's raw SQL
Daily Exercise: Create day22/sqlalchemy_basics/:

database.py: engine, SessionLocal, Base setup
models.py: User model with SQLAlchemy (id, email, name, created_at)
crud.py: functions to create, read, update, delete users
main.py: test script demonstrating all CRUD operations
Alembic not needed yet â€” use Base.metadata.create_all()
Deliverable:

SQLAlchemy models defined
CRUD operations via ORM
Database populated with test data
Comparison notes: ORM vs raw SQL
Why It Matters: ORMs abstract SQL complexity and provide type safety. SQLAlchemy is industry standard for Python backends â€” FastAPI, Flask, and Django use it.

If Behind: Just create the User model and one function to insert a user.

Day 23: FastAPI + SQLAlchemy Integration
Prerequisites: Days 21-22 complete

Where to Learn:

FastAPI SQL Databases Tutorial
SQLAlchemy Sessions
Review Day 19 (Dependency Injection)
120-Minute Breakdown:

0-30m: Learn database session management in FastAPI
30-60m: Create get_db() dependency for session handling
60-100m: Integrate Day 22's CRUD with FastAPI routes
100-115m: Add proper error handling (user not found, duplicate email)
115-120m: Test all endpoints with real database
Daily Exercise: Build day23/fastapi_sqlalchemy/:

Copy Day 22's database setup
Create dependencies.py with get_db() session dependency
Update routes to use db: Session = Depends(get_db)
POST /users â†’ insert to database
GET /users â†’ query all from database
GET /users/{id} â†’ query single user
PUT /users/{id} â†’ update in database
DELETE /users/{id} â†’ delete from database
Deliverable:

FastAPI routes connected to PostgreSQL
Session management via dependency injection
All CRUD operations persisting to database
Postman collection updated for real database
Why It Matters: This is the foundation of every production API. Session management prevents database connection leaks â€” a critical production skill.

If Behind: Just implement POST and GET routes with database. Skip update/delete.

Day 24: Relationships & Joins
Prerequisites: Days 21-23 complete

Where to Learn:

SQLAlchemy Relationships
FastAPI Advanced SQL Tutorial
SQL Joins Explained
120-Minute Breakdown:

0-35m: Learn one-to-many relationships (User has many Posts)
35-60m: Understand foreign keys, relationship(), backref
60-100m: Add Post model related to User
100-115m: Create endpoints to create posts and fetch user with posts
115-120m: Test nested data retrieval
Daily Exercise: Enhance day24/relationships_api/:

Add Post model (id, title, content, user_id, created_at)
Define relationship: User.posts = relationship("Post", back_populates="owner")
POST /posts â†’ create post for user
GET /users/{id}/posts â†’ get user with all posts (eager loading)
Demonstrate join query with selectinload()
Deliverable:

Related models (User, Post)
Foreign key constraint
Nested data retrieval working
Demo showing user with multiple posts
Why It Matters: Real applications have complex relationships (users, orders, products). Understanding ORMs relationships prevents N+1 query problems in production.

If Behind: Just add the Post model with foreign key. Create one post. Skip the nested retrieval.

Day 25-26: Complete CRUD API Project
Prerequisites: Days 15-24 complete

Where to Learn:

Review all Week 3-4 materials
FastAPI Best Practices
REST API Naming Conventions
120-Minute Breakdown (Each Day):

Day 25: 0-60m: Design complete API (Users, Posts, Comments)
Day 25: 60-120m: Implement all models and relationships
Day 26: 0-90m: Implement all CRUD endpoints with proper error handling
Day 26: 90-120m: Add filtering, sorting, pagination to GET endpoints
Daily Exercise: Build day25-26/blog_api/:

Structure:
blog_api/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ database.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ post.py
â”‚   â”‚   â””â”€â”€ comment.py
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ post.py
â”‚   â”‚   â””â”€â”€ comment.py
â”‚   â”œâ”€â”€ crud/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ post.py
â”‚   â”‚   â””â”€â”€ comment.py
â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ users.py
â”‚   â”‚   â”œâ”€â”€ posts.py
â”‚   â”‚   â””â”€â”€ comments.py
â”‚   â””â”€â”€ dependencies.py
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
Features:

Users CRUD
Posts CRUD (belongs to user)
Comments CRUD (belongs to post)
GET /posts?limit=10&skip=0&sort=created_at
GET /users/{id}/posts (all posts by user)
GET /posts/{id}/comments (all comments on post)
Deliverable:

Production-quality folder structure
3 related models with proper relationships
All CRUD endpoints for each resource
Pagination, filtering, sorting
Complete Postman collection
Professional README with API documentation
Weekly Deliverables Checklist (Week 3-4):

âœ… FastAPI basics mastered (routing, request/response)
âœ… Pydantic 2.0 models with validation
âœ… Async programming implemented
âœ… Dependency injection throughout
âœ… PostgreSQL + SQLAlchemy integrated
âœ… Relationships and joins working
âœ… Complete CRUD API with 3 entities
âœ… Professional API documentation
Why It Matters: This project demonstrates API design skills required for 90% of backend positions. Clean structure and proper relationships show you understand production patterns.

If Behind: Just implement Users and Posts. Skip Comments. Minimal endpoints (POST, GET).

Day 27-28: Polish & Documentation
Prerequisites: Days 25-26 complete

120-Minute Breakdown (Each Day):

Day 27: Add comprehensive docstrings to all functions
Day 27: Improve OpenAPI docs with descriptions, examples
Day 27: Add response models for error cases
Day 28: Create detailed README with endpoint documentation
Day 28: Add environment variable configuration
Day 28: Create demo data seeding script
Daily Exercise: Polish day27-28/blog_api_final/:

Add docstrings with parameter descriptions
Use response_model and response_description in decorators
Add examples to Pydantic models (Config.json_schema_extra)
Create .env.example file
Write seed_data.py to populate database
Professional README with curl examples
Deliverable:

Fully documented codebase
Rich OpenAPI documentation
Environment configuration setup
Seeding script for testing
Portfolio-ready README
Why It Matters: Documentation quality separates junior from mid-level developers. Good docs show professionalism and make collaboration easier.

If Behind: Just write a basic README with setup instructions.

ðŸ—“ï¸ WEEK 5-6: Database Layer & ORM Mastery
Weekly Objective: Master advanced SQLAlchemy patterns including migrations (Alembic), complex queries, transactions, the repository pattern, and async database operations. Build a multi-entity relational API with proper architectural layers.

Day 29: Alembic Database Migrations
Prerequisites: Weeks 3-4 complete

Where to Learn:

Alembic Documentation
FastAPI with Alembic
Database Migrations Explained
120-Minute Breakdown:

0-30m: Understand migrations concept (version control for database schema)
30-55m: Install Alembic, initialize in project
55-90m: Create initial migration from existing models
90-115m: Practice schema changes (add column, modify column, add index)
115-120m: Apply and rollback migrations
Daily Exercise: Setup day29/migrations_practice/:

Initialize Alembic: alembic init alembic
Configure alembic.ini and env.py to use SQLAlchemy models
Generate migration: alembic revision --autogenerate -m "Initial"
Apply: alembic upgrade head
Add bio field to User model
Generate new migration, apply it
Test rollback: alembic downgrade -1
Deliverable:

Alembic configured in project
Migration files for schema changes
Documentation on migration workflow
Commands cheat sheet
Why It Matters: Production databases require safe schema evolution. Alembic migrations enable zero-downtime deployments and team collaboration on schema changes.

If Behind: Just initialize Alembic and create one migration. Don't worry about rollback.

Day 30: Complex Queries & Filtering
Prerequisites: Day 29 complete

Where to Learn:

SQLAlchemy Querying Guide
Advanced SQLAlchemy Queries
SQL WHERE Clause
120-Minute Breakdown:

0-30m: Learn filter(), filter_by(), and complex conditions (AND, OR)
30-60m: Understand order_by(), limit(), offset()
60-95m: Implement search functionality (ILIKE for case-insensitive)
95-115m: Add date range filtering
115-120m: Optimize with indexes
Daily Exercise: Enhance day30/advanced_queries/:

GET /posts?search=python (searches title and content)
GET /posts?author=john&sort=created_at&order=desc
GET /posts?from_date=2025-01-01&to_date=2025-12-31
GET /posts?tags=python,fastapi (if you add tags)
Add database indexes on frequently filtered columns
Deliverable:

Advanced filtering endpoints
Search functionality working
Date range queries implemented
Database indexes added via migration
Why It Matters: Real APIs need powerful search and filtering. LinkedIn, Twitter, e-commerce â€” all use complex queries. Understanding query optimization prevents slow endpoints.

If Behind: Just implement simple search on one field (e.g., title contains keyword).

Day 31: Transactions & Data Integrity
Prerequisites: Days 29-30 complete

Where to Learn:

SQLAlchemy Transactions
Database Transactions Explained
ACID Properties
120-Minute Breakdown:

0-30m: Learn ACID properties and transaction isolation
30-55m: Understand session.commit(), session.rollback()
55-95m: Implement multi-step operation with transaction
95-115m: Handle transaction failures and rollbacks
115-120m: Add unique constraints and handle integrity errors
Daily Exercise: Build day31/transactions_demo/:

Create transfer operation: deduct from one user, add to another
Wrap in transaction â€” if second step fails, rollback first
Add unique constraint on User.email
Handle IntegrityError when duplicate email
Demonstrate transaction rollback on error
Deliverable:

Multi-step transactional operations
Proper error handling with rollback
Database constraints enforced
Demo showing atomicity (all-or-nothing)
Why It Matters: Financial apps, inventory systems, bookings â€” all require transactions. Understanding atomicity prevents data corruption in production.

If Behind: Just demonstrate one commit() and one rollback(). Skip the complex multi-step operation.

Day 32: Repository Pattern
Prerequisites: Days 29-31 complete

Where to Learn:

Repository Pattern Explained
ArjanCodes: Repository Pattern
Review Week 1-2 OOP principles
120-Minute Breakdown:

0-35m: Understand separation of concerns (data access vs business logic)
35-60m: Learn repository pattern structure
60-100m: Create UserRepository class with CRUD methods
100-115m: Refactor routes to use repository instead of direct CRUD
115-120m: Compare old vs new structure
Daily Exercise: Refactor day32/repository_pattern/:

Create repositories/ folder
base_repository.py: Generic base class with common methods
user_repository.py: UserRepository(BaseRepository) with user-specific queries
Move all database logic from crud/ to repositories
Update routers to use user_repo.get_all() instead of direct queries
Routes should only have: validation â†’ repository call â†’ response
Deliverable:

Repository classes implemented
Clear separation: routes â†’ repositories â†’ database
Business logic isolated from data access
Cleaner, testable code structure
Why It Matters: Repository pattern makes code testable and maintainable. It's standard in enterprise applications and improves code quality dramatically.

If Behind: Just create one repository class with get_all() and get_by_id(). Use it in one route.

Day 33: Service Layer Pattern
Prerequisites: Day 32 complete

Where to Learn:

Service Layer Pattern
Clean Architecture
Review Day 19 (Dependency Injection)
120-Minute Breakdown:

0-30m: Understand service layer (business logic orchestration)
30-60m: Learn difference between repository (data) and service (logic)
60-100m: Create UserService with business operations
100-115m: Add validation and business rules to service
115-120m: Update routes to use services
Daily Exercise: Add day33/service_layer/:

Create services/ folder
user_service.py: UserService class
Methods like create_user_with_validation(), deactivate_user(), get_user_with_posts()
Business rules: check email uniqueness, validate age, auto-generate username
Routes become thin: request â†’ service â†’ response
Services use repositories for data access
Deliverable:

Service layer implemented
Business logic extracted from routes
Clear architecture: routes â†’ services â†’ repositories â†’ database
Comprehensive comments explaining layers
Why It Matters: Service layer is where complex business logic lives. This three-layer architecture (controller-service-repository) is industry standard for scalable APIs.

If Behind: Just create one service class with one method that uses the repository.

Day 34: Async SQLAlchemy
Prerequisites: Days 29-33 complete

Where to Learn:

SQLAlchemy Async Documentation
FastAPI Async SQL
Review Day 18 (Async Programming)
120-Minute Breakdown:

0-35m: Learn async database engine and session
35-60m: Convert models to async (AsyncSession)
60-100m: Update repositories to use async methods
100-115m: Convert all routes to async database calls
115-120m: Test performance improvement
Daily Exercise: Convert day34/async_database/:

Install asyncpg: pip install asyncpg
Update database.py to use create_async_engine
Change session to AsyncSession
Update repositories: async def get_all(), use await session.execute()
Update all routes to async def with await
Test concurrent requests
Deliverable:

Fully async database layer
All repositories async
Performance comparison with sync version
Notes on when async provides benefits
Why It Matters: Async database operations allow handling thousands of concurrent users. Required for high-traffic applications and real-time features.

If Behind: Just convert one repository method to async. Keep the rest synchronous.

Day 35: Many-to-Many Relationships
Prerequisites: Days 29-34 complete

Where to Learn:

SQLAlchemy Many-to-Many
Association Tables
SQL Many-to-Many Tutorial
120-Minute Breakdown:

0-30m: Understand many-to-many relationships (students â†” courses)
30-60m: Learn association tables and secondary parameter
60-95m: Implement Post â†” Tag relationship
95-115m: Create endpoints to manage tags
115-120m: Query posts by tags
Daily Exercise: Add to day35/many_to_many/:

Create Tag model (id, name)
Create association table post_tags
Add relationship: Post.tags = relationship("Tag", secondary=post_tags, back_populates="posts")
POST /tags â†’ create tag
POST /posts/{id}/tags â†’ add tag to post
GET /tags/{id}/posts â†’ get all posts with tag
Alembic migration for new tables
Deliverable:

Many-to-many relationship implemented
Association table created
CRUD operations for managing relationships
Demo showing posts with multiple tags
Why It Matters: E-commerce (products â†” categories), social media (users â†” groups), education (students â†” courses) â€” all use many-to-many. Critical for complex data models.

If Behind: Just create the models and association table. Skip the endpoints.

Day 36-38: E-Commerce API Project (Part 1)
Prerequisites: Days 29-35 complete

Where to Learn:

Review all Week 5-6 materials
E-Commerce Database Design
120-Minute Breakdown (3 Days):

Day 36: Design schema (Users, Products, Categories, Orders, OrderItems)
Day 36: Create all models with relationships
Day 37: Implement repositories for all entities
Day 37: Implement service layer with business logic
Day 38: Create all CRUD endpoints
Day 38: Add product filtering and search
Daily Exercise: Build day36-38/ecommerce_api/:

Models:

User (id, email, name, role: customer/admin)
Category (id, name, description)
Product (id, name, price, stock, category_id) â€” many categories via association
Order (id, user_id, total, status, created_at)
OrderItem (id, order_id, product_id, quantity, price)
Relationships:

User â†’ Orders (one-to-many)
Product â†’ Categories (many-to-many)
Order â†’ OrderItems (one-to-many)
Product â†’ OrderItems (one-to-many)
Features:

Products CRUD with category assignment
Search products by name, filter by category, price range
Create order (reduces product stock)
Get user's order history
Admin endpoints (protected by role)
Deliverable:

Complete e-commerce data model
All relationships properly defined
Repository and service layers
CRUD endpoints for all entities
Order creation with stock validation
Alembic migrations
Why It Matters: E-commerce APIs demonstrate complex business logic, transactions, and relationships â€” exactly what interviewers ask about. Perfect portfolio piece.

If Behind: Just implement Users, Products, and Orders. Skip Categories and OrderItems.

Day 39-42: E-Commerce API Project (Part 2)
Prerequisites: Days 36-38 complete

120-Minute Breakdown (4 Days):

Day 39: Add inventory management (stock tracking, low stock alerts)
Day 39: Implement order status workflow (pending â†’ paid â†’ shipped â†’ delivered)
Day 40: Add product reviews (User reviews Product, rating + comment)
Day 40: Calculate average product ratings
Day 41: Implement shopping cart (CartItem model, add/remove/clear)
Day 41: Cart checkout creates Order
Day 42: Add advanced queries (top products, user spending, sales reports)
Day 42: Polish and documentation
Daily Exercise: Enhance day39-42/ecommerce_api_complete/:

New Features:

Stock validation on order (transaction rollback if insufficient)
Order status transitions with validation
Review system with rating aggregation
Cart functionality (session-based or user-based)
Analytics endpoints:
GET /admin/products/top-selling
GET /admin/users/{id}/spending
GET /admin/sales/report?from_date&to_date
Deliverable:

Complete e-commerce platform
Complex business logic with transactions
Analytics and reporting features
Professional documentation
Postman collection with all workflows
ER diagram of database schema
Weekly Deliverables Checklist (Week 5-6):

âœ… Alembic migrations mastered
âœ… Complex queries and filtering implemented
âœ… Transaction handling with ACID properties
âœ… Repository pattern applied
âœ… Service layer with business logic
âœ… Async database operations
âœ… Many-to-many relationships
âœ… Complete e-commerce API with 5+ entities
Why It Matters: This project showcases advanced backend skills: complex data models, business logic, transactions, and real-world features. Interviewers will be impressed by this level of complexity.

If Behind: Focus on core e-commerce features: Products, Orders, OrderItems. Skip reviews and cart.

WEEK 7-8: Modular Architecture & Authentication
Weekly Objective: Master modular application design, authentication (JWT, OAuth2), authorization (role-based access), and build a production-grade multi-module FastAPI application with secure endpoints.

Day 43: Monolithic vs Modular Architecture
Prerequisites: Weeks 1-6 complete

Where to Learn:

Microservices vs Monolith
FastAPI Project Structure
ArjanCodes: Software Architecture
120-Minute Breakdown:

0-35m: Understand monolithic, modular monolith, microservices
35-60m: Learn when to use each architecture
60-95m: Design modular FastAPI structure
95-115m: Refactor previous project into modules
115-120m: Document architecture decisions
Daily Exercise: Refactor day43/modular_structure/:

app/
â”œâ”€â”€ main.py               # App factory
â”œâ”€â”€ config.py             # Settings
â”œâ”€â”€ database.py           # DB connection
â”œâ”€â”€ dependencies.py       # Global dependencies
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”œâ”€â”€ schemas.py
â”‚   â”‚   â”œâ”€â”€ repository.py
â”‚   â”‚   â”œâ”€â”€ service.py
â”‚   â”‚   â””â”€â”€ router.py
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â””â”€â”€ (same structure)
â”‚   â””â”€â”€ orders/
â”‚       â””â”€â”€ (same structure)
â””â”€â”€ shared/
    â”œâ”€â”€ exceptions.py
    â”œâ”€â”€ utils.py
    â””â”€â”€ middleware.py
Deliverable:

Modular folder structure
Each module self-contained
Shared utilities extracted
App factory pattern with module registration
Documentation explaining structure
Why It Matters: Modular design enables team collaboration and independent deployment. Understanding this separates mid-level from senior engineers.

If Behind: Just separate your code into users/ and products/ folders. Basic separation is fine.

Day 44: Configuration Management
Prerequisites: Day 43 complete

Where to Learn:

Pydantic Settings
FastAPI Settings
12-Factor App Config
120-Minute Breakdown:

0-25m: Learn environment-based configuration
25-50m: Install pydantic-settings, create Settings class
50-90m: Move all config to environment variables
90-115m: Create .env, .env.example, .env.test
115-120m: Add config dependency
Daily Exercise: Add to day44/config_management/:

Install: pip install pydantic-settings python-dotenv
Create config.py:
# Empty code structure placeholder
class Settings(BaseSettings):
    # DATABASE_URL, SECRET_KEY, DEBUG, etc.
    model_config = SettingsConfigDict(env_file=".env")
Create .env.example (safe to commit)
Add .env to .gitignore
Use settings = Settings() dependency in routes
Deliverable:

Centralized configuration
Environment variables for all secrets
Different configs for dev/test/prod
Security improved (no hardcoded secrets)
Why It Matters: Production apps run in multiple environments. Configuration management is mandatory for deployment and security.

If Behind: Just create .env file with database URL. Use python-dotenv to load it.

Day 45: Password Hashing & Security
Prerequisites: Day 44 complete

Where to Learn:

Passlib Documentation
Password Hashing Best Practices
FastAPI Security
120-Minute Breakdown:

0-30m: Learn password hashing (bcrypt), why never store plaintext
30-55m: Install passlib, create password utilities
55-90m: Implement user registration with hashed passwords
90-115m: Implement login verification
115-120m: Test security
Daily Exercise: Build day45/password_security/:

Install: pip install passlib[bcrypt]
Create security.py:
# Empty code structure placeholder
def hash_password(password: str) -> str:
    # Use bcrypt
    pass

def verify_password(plain: str, hashed: str) -> bool:
    # Verify with bcrypt
    pass
Update User model: hashed_password field
POST /register â†’ hash password before saving
POST /login â†’ verify password, return success/failure
Deliverable:

Password hashing implemented
Registration with secure storage
Login verification working
Never log or return passwords
Why It Matters: Security breaches destroy companies. Proper password handling is non-negotiable for any production application.

If Behind: Just implement hash_password() and use it during registration.

Day 46-47: JWT Authentication
Prerequisites: Day 45 complete

Where to Learn:

JWT.io Introduction
FastAPI JWT Tutorial
Python-JOSE Documentation
120-Minute Breakdown (2 Days):

Day 46: 0-40m: Learn JWT structure (header.payload.signature)
Day 46: 40-80m: Install python-jose, create token utilities
Day 46: 80-120m: Implement token creation on login
Day 47: 0-60m: Implement token validation dependency
Day 47: 60-100m: Protect routes with authentication
Day 47: 100-120m: Add token expiration and refresh
Daily Exercise: Build day46-47/jwt_auth/:

Install: pip install python-jose[cryptography]
Create security.py:
# Empty code structure placeholder
def create_access_token(data: dict, expires_delta: timedelta) -> str:
    # Create JWT
    pass

def decode_token(token: str) -> dict:
    # Verify and decode JWT
    pass
POST /login â†’ returns {"access_token": "...", "token_type": "bearer"}
Create get_current_user() dependency that validates token
Protect routes: GET /users/me requires authentication
Handle expired tokens, invalid tokens
Deliverable:

JWT token generation on login
Token validation dependency
Protected routes requiring authentication
Token expiration handling
Postman collection with Bearer token
Why It Matters: JWT is the industry standard for stateless authentication. Every modern API uses it â€” mastering JWT is mandatory for backend roles.

If Behind: Just implement token creation and return it on login. Skip validation and protected routes.

Day 48: OAuth2 Password Flow
Prerequisites: Days 46-47 complete

Where to Learn:

FastAPI OAuth2
OAuth 2.0 Explained
Review FastAPI security documentation
120-Minute Breakdown:

0-30m: Understand OAuth2 password flow
30-60m: Implement OAuth2PasswordBearer scheme
60-95m: Create token endpoint following OAuth2 spec
95-115m: Update authentication to use OAuth2
115-120m: Test with FastAPI's built-in auth UI
Daily Exercise: Enhance day48/oauth2_flow/:

Use OAuth2PasswordBearer(tokenUrl="token")
POST /token (not /login) accepting username and password as form data
Return OAuth2-compliant response
Update all protected routes to use OAuth2 scheme
Test authentication in /docs interactive UI
Deliverable:

OAuth2-compliant authentication
Interactive docs with "Authorize" button working
All protected endpoints using OAuth2 scheme
Demo video showing authentication flow in Swagger UI
Why It Matters: OAuth2 is the standard for API authentication. Following the spec ensures compatibility with API gateways, mobile apps, and third-party integrations.

If Behind: Just rename your /login endpoint to /token and make it accept form data instead of JSON.

Day 49: Role-Based Access Control (RBAC)
Prerequisites: Day 48 complete

Where to Learn:

RBAC Explained
FastAPI Advanced Dependencies
Authorization Best Practices
120-Minute Breakdown:

0-30m: Learn roles vs permissions, RBAC principles
30-60m: Add role field to User model (admin, user, moderator)
60-95m: Create role-checking dependencies
95-115m: Protect admin routes with role validation
115-120m: Test different user roles
Daily Exercise: Build day49/rbac/:

Add role: str to User model with Enum (admin, user)
Update registration to set default role
Create dependencies:
# Empty code structure placeholder
def require_role(required_role: str):
    def role_checker(current_user: User = Depends(get_current_user)):
        if current_user.role != required_role:
            raise HTTPException(403, "Insufficient permissions")
        return current_user
    return role_checker
Protect admin routes: dependencies=[Depends(require_role("admin"))]
Test: regular user cannot access admin endpoints
Deliverable:

User roles implemented
Role-based access control working
Admin-only endpoints protected
Proper 403 Forbidden responses
Test cases for different roles
Why It Matters: Every production app has different user types. RBAC prevents unauthorized access and is fundamental to security architecture.

If Behind: Just add an is_admin boolean field and check it in one protected route.

Day 50: Refresh Tokens
Prerequisites: Days 46-49 complete

Where to Learn:

Refresh Tokens Explained
FastAPI Refresh Token Pattern
Review JWT documentation
120-Minute Breakdown:

0-30m: Understand access vs refresh tokens
30-60m: Design token storage strategy
60-95m: Implement refresh token generation
95-115m: Create token refresh endpoint
115-120m: Handle token rotation
Daily Exercise: Enhance day50/refresh_tokens/:

Modify login to return both tokens:
{
    "access_token": "...",
    "refresh_token": "...",
    "token_type": "bearer"
}
Store refresh tokens in database (RefreshToken model)
Create POST /token/refresh accepting refresh token
Return new access token
Implement token rotation (invalidate old refresh token)
Add token revocation endpoint
Deliverable:

Dual token system (access + refresh)
Token refresh working
Refresh tokens stored in database
Token revocation capability
Security documentation
Why It Matters: Long-lived access tokens are security risks. Refresh tokens enable secure, seamless user sessions â€” standard in mobile and SPA applications.

If Behind: Just return a longer-lived access token. Skip the refresh token complexity.

Day 51-52: Permission System
Prerequisites: Days 43-50 complete

Where to Learn:

Permission-Based Access Control
FastAPI Advanced Security
Review RBAC from Day 49
120-Minute Breakdown (2 Days):

Day 51: 0-60m: Design permission system (create:post, delete:user, etc.)
Day 51: 60-120m: Create Permission and RolePermission models
Day 52: 0-60m: Implement permission checking dependency
Day 52: 60-100m: Assign permissions to roles
Day 52: 100-120m: Test granular permissions
Daily Exercise: Build day51-52/permissions/:

Models:
Permission (id, name, description)
RolePermission (role, permission_id) â€” many-to-many
Seed permissions: create:post, edit:post, delete:post, manage:users
Assign permissions to roles
Create permission checker:
# Empty code structure placeholder
def require_permission(permission: str):
    async def permission_checker(current_user: User = Depends(get_current_user)):
        # Check if user's role has permission
        pass
    return permission_checker
Protect endpoints with specific permissions
Deliverable:

Granular permission system
Roles with assigned permissions
Permission-based route protection
Admin interface to manage permissions
Complete authorization flow
Why It Matters: Complex applications need fine-grained access control. Permission systems enable scalable authorization that doesn't require code changes for new rules.

If Behind: Just create a list of permissions as strings and check if user's role has the required permission.

Day 53-56: Multi-Module Application Project
Prerequisites: Days 43-52 complete

120-Minute Breakdown (4 Days):

Day 53: Set up project structure with 4 modules
Day 53: Configure shared authentication and database
Day 54: Implement users module (registration, login, profile)
Day 54: Implement auth middleware
Day 55: Implement products module (CRUD with permissions)
Day 55: Implement orders module (checkout, history)
Day 56: Implement admin module (user management, reports)
Day 56: Integration testing and documentation
Daily Exercise: Build day53-56/modular_ecommerce/:

app/
â”œâ”€â”€ main.py
â”œâ”€â”€ config.py
â”œâ”€â”€ database.py
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ models.py (User, RefreshToken, Permission)
â”‚   â”‚   â”œâ”€â”€ schemas.py (Login, Register, Token)
â”‚   â”‚   â”œâ”€â”€ service.py (authentication logic)
â”‚   â”‚   â”œâ”€â”€ dependencies.py (get_current_user, require_permission)
â”‚   â”‚   â””â”€â”€ router.py (register, login, refresh, logout)
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ models.py (UserProfile)
â”‚   â”‚   â”œâ”€â”€ service.py (profile management)
â”‚   â”‚   â””â”€â”€ router.py (GET/PUT /me, GET /users/{id})
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”œâ”€â”€ models.py (Product, Category, Review)
â”‚   â”‚   â”œâ”€â”€ service.py (business logic)
â”‚   â”‚   â””â”€â”€ router.py (CRUD with permissions)
â”‚   â”œâ”€â”€ orders/
â”‚   â”‚   â”œâ”€â”€ models.py (Order, OrderItem)
â”‚   â”‚   â”œâ”€â”€ service.py (checkout, stock management)
â”‚   â”‚   â””â”€â”€ router.py (create, list, track)
â”‚   â””â”€â”€ admin/
â”‚       â”œâ”€â”€ service.py (user management, analytics)
â”‚       â””â”€â”€ router.py (admin-only endpoints)
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”œâ”€â”€ pagination.py
â”‚   â””â”€â”€ responses.py
â””â”€â”€ tests/ (basic structure)
Features:

Auth Module:

Registration with email verification flag
Login with JWT + refresh token
Token refresh and revocation
Role and permission management
Users Module:

User profile CRUD
Public profile view
Profile picture URL field
User search (admin only)
Products Module:

CRUD with category support
Search and filtering
Review system
Stock tracking
Orders Module:

Cart to order conversion
Stock validation with transactions
Order history
Status tracking
Admin Module:

User management (ban, role changes)
Sales analytics
System monitoring endpoints
Deliverable:

Complete modular application
All modules independently functional
Shared authentication across modules
RBAC with permissions
Professional API documentation
Postman collection organized by modules
ER diagram showing all relationships
Weekly Deliverables Checklist (Week 7-8):

âœ… Modular architecture implemented
âœ… Environment-based configuration
âœ… Secure password hashing
âœ… JWT authentication with refresh tokens
âœ… OAuth2 compliance
âœ… Role-based access control
âœ… Granular permission system
âœ… Production-ready multi-module application
Why It Matters: This architecture mirrors real production applications. Modular design + authentication + authorization demonstrates senior-level backend engineering skills.

If Behind: Focus on Auth and Users modules with basic RBAC. Products and Orders can be simplified (no reviews, basic order creation).

WEEK 7-8: Modular Architecture & Authentication
Weekly Objective: Master modular application design, authentication (JWT, OAuth2), authorization (role-based access), and build a production-grade multi-module FastAPI application with secure endpoints.

Day 43: Monolithic vs Modular Architecture
Prerequisites: Weeks 1-6 complete

Where to Learn:

Microservices vs Monolith
FastAPI Project Structure
ArjanCodes: Software Architecture
120-Minute Breakdown:

0-35m: Understand monolithic, modular monolith, microservices
35-60m: Learn when to use each architecture
60-95m: Design modular FastAPI structure
95-115m: Refactor previous project into modules
115-120m: Document architecture decisions
Daily Exercise: Refactor day43/modular_structure/:

app/
â”œâ”€â”€ main.py               # App factory
â”œâ”€â”€ config.py             # Settings
â”œâ”€â”€ database.py           # DB connection
â”œâ”€â”€ dependencies.py       # Global dependencies
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py
â”‚   â”‚   â”œâ”€â”€ schemas.py
â”‚   â”‚   â”œâ”€â”€ repository.py
â”‚   â”‚   â”œâ”€â”€ service.py
â”‚   â”‚   â””â”€â”€ router.py
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â””â”€â”€ (same structure)
â”‚   â””â”€â”€ orders/
â”‚       â””â”€â”€ (same structure)
â””â”€â”€ shared/
    â”œâ”€â”€ exceptions.py
    â”œâ”€â”€ utils.py
    â””â”€â”€ middleware.py
Deliverable:

Modular folder structure
Each module self-contained
Shared utilities extracted
App factory pattern with module registration
Documentation explaining structure
Why It Matters: Modular design enables team collaboration and independent deployment. Understanding this separates mid-level from senior engineers.

If Behind: Just separate your code into users/ and products/ folders. Basic separation is fine.

Day 44: Configuration Management
Prerequisites: Day 43 complete

Where to Learn:

Pydantic Settings
FastAPI Settings
12-Factor App Config
120-Minute Breakdown:

0-25m: Learn environment-based configuration
25-50m: Install pydantic-settings, create Settings class
50-90m: Move all config to environment variables
90-115m: Create .env, .env.example, .env.test
115-120m: Add config dependency
Daily Exercise: Add to day44/config_management/:

Install: pip install pydantic-settings python-dotenv
Create config.py:
# Empty code structure placeholder
class Settings(BaseSettings):
    # DATABASE_URL, SECRET_KEY, DEBUG, etc.
    model_config = SettingsConfigDict(env_file=".env")
Create .env.example (safe to commit)
Add .env to .gitignore
Use settings = Settings() dependency in routes
Deliverable:

Centralized configuration
Environment variables for all secrets
Different configs for dev/test/prod
Security improved (no hardcoded secrets)
Why It Matters: Production apps run in multiple environments. Configuration management is mandatory for deployment and security.

If Behind: Just create .env file with database URL. Use python-dotenv to load it.

Day 45: Password Hashing & Security
Prerequisites: Day 44 complete

Where to Learn:

Passlib Documentation
Password Hashing Best Practices
FastAPI Security
120-Minute Breakdown:

0-30m: Learn password hashing (bcrypt), why never store plaintext
30-55m: Install passlib, create password utilities
55-90m: Implement user registration with hashed passwords
90-115m: Implement login verification
115-120m: Test security
Daily Exercise: Build day45/password_security/:

Install: pip install passlib[bcrypt]
Create security.py:
# Empty code structure placeholder
def hash_password(password: str) -> str:
    # Use bcrypt
    pass

def verify_password(plain: str, hashed: str) -> bool:
    # Verify with bcrypt
    pass
Update User model: hashed_password field
POST /register â†’ hash password before saving
POST /login â†’ verify password, return success/failure
Deliverable:

Password hashing implemented
Registration with secure storage
Login verification working
Never log or return passwords
Why It Matters: Security breaches destroy companies. Proper password handling is non-negotiable for any production application.

If Behind: Just implement hash_password() and use it during registration.

Day 46-47: JWT Authentication
Prerequisites: Day 45 complete

Where to Learn:

JWT.io Introduction
FastAPI JWT Tutorial
Python-JOSE Documentation
120-Minute Breakdown (2 Days):

Day 46: 0-40m: Learn JWT structure (header.payload.signature)
Day 46: 40-80m: Install python-jose, create token utilities
Day 46: 80-120m: Implement token creation on login
Day 47: 0-60m: Implement token validation dependency
Day 47: 60-100m: Protect routes with authentication
Day 47: 100-120m: Add token expiration and refresh
Daily Exercise: Build day46-47/jwt_auth/:

Install: pip install python-jose[cryptography]
Create security.py:
# Empty code structure placeholder
def create_access_token(data: dict, expires_delta: timedelta) -> str:
    # Create JWT
    pass

def decode_token(token: str) -> dict:
    # Verify and decode JWT
    pass
POST /login â†’ returns {"access_token": "...", "token_type": "bearer"}
Create get_current_user() dependency that validates token
Protect routes: GET /users/me requires authentication
Handle expired tokens, invalid tokens
Deliverable:

JWT token generation on login
Token validation dependency
Protected routes requiring authentication
Token expiration handling
Postman collection with Bearer token
Why It Matters: JWT is the industry standard for stateless authentication. Every modern API uses it â€” mastering JWT is mandatory for backend roles.

If Behind: Just implement token creation and return it on login. Skip validation and protected routes.

Day 48: OAuth2 Password Flow
Prerequisites: Days 46-47 complete

Where to Learn:

FastAPI OAuth2
OAuth 2.0 Explained
Review FastAPI security documentation
120-Minute Breakdown:

0-30m: Understand OAuth2 password flow
30-60m: Implement OAuth2PasswordBearer scheme
60-95m: Create token endpoint following OAuth2 spec
95-115m: Update authentication to use OAuth2
115-120m: Test with FastAPI's built-in auth UI
Daily Exercise: Enhance day48/oauth2_flow/:

Use OAuth2PasswordBearer(tokenUrl="token")
POST /token (not /login) accepting username and password as form data
Return OAuth2-compliant response
Update all protected routes to use OAuth2 scheme
Test authentication in /docs interactive UI
Deliverable:

OAuth2-compliant authentication
Interactive docs with "Authorize" button working
All protected endpoints using OAuth2 scheme
Demo video showing authentication flow in Swagger UI
Why It Matters: OAuth2 is the standard for API authentication. Following the spec ensures compatibility with API gateways, mobile apps, and third-party integrations.

If Behind: Just rename your /login endpoint to /token and make it accept form data instead of JSON.

Day 49: Role-Based Access Control (RBAC)
Prerequisites: Day 48 complete

Where to Learn:

RBAC Explained
FastAPI Advanced Dependencies
Authorization Best Practices
120-Minute Breakdown:

0-30m: Learn roles vs permissions, RBAC principles
30-60m: Add role field to User model (admin, user, moderator)
60-95m: Create role-checking dependencies
95-115m: Protect admin routes with role validation
115-120m: Test different user roles
Daily Exercise: Build day49/rbac/:

Add role: str to User model with Enum (admin, user)
Update registration to set default role
Create dependencies:
# Empty code structure placeholder
def require_role(required_role: str):
    def role_checker(current_user: User = Depends(get_current_user)):
        if current_user.role != required_role:
            raise HTTPException(403, "Insufficient permissions")
        return current_user
    return role_checker
Protect admin routes: dependencies=[Depends(require_role("admin"))]
Test: regular user cannot access admin endpoints
Deliverable:

User roles implemented
Role-based access control working
Admin-only endpoints protected
Proper 403 Forbidden responses
Test cases for different roles
Why It Matters: Every production app has different user types. RBAC prevents unauthorized access and is fundamental to security architecture.

If Behind: Just add an is_admin boolean field and check it in one protected route.

Day 50: Refresh Tokens
Prerequisites: Days 46-49 complete

Where to Learn:

Refresh Tokens Explained
FastAPI Refresh Token Pattern
Review JWT documentation
120-Minute Breakdown:

0-30m: Understand access vs refresh tokens
30-60m: Design token storage strategy
60-95m: Implement refresh token generation
95-115m: Create token refresh endpoint
115-120m: Handle token rotation
Daily Exercise: Enhance day50/refresh_tokens/:

Modify login to return both tokens:
{
    "access_token": "...",
    "refresh_token": "...",
    "token_type": "bearer"
}
Store refresh tokens in database (RefreshToken model)
Create POST /token/refresh accepting refresh token
Return new access token
Implement token rotation (invalidate old refresh token)
Add token revocation endpoint
Deliverable:

Dual token system (access + refresh)
Token refresh working
Refresh tokens stored in database
Token revocation capability
Security documentation
Why It Matters: Long-lived access tokens are security risks. Refresh tokens enable secure, seamless user sessions â€” standard in mobile and SPA applications.

If Behind: Just return a longer-lived access token. Skip the refresh token complexity.

Day 51-52: Permission System
Prerequisites: Days 43-50 complete

Where to Learn:

Permission-Based Access Control
FastAPI Advanced Security
Review RBAC from Day 49
120-Minute Breakdown (2 Days):

Day 51: 0-60m: Design permission system (create:post, delete:user, etc.)
Day 51: 60-120m: Create Permission and RolePermission models
Day 52: 0-60m: Implement permission checking dependency
Day 52: 60-100m: Assign permissions to roles
Day 52: 100-120m: Test granular permissions
Daily Exercise: Build day51-52/permissions/:

Models:
Permission (id, name, description)
RolePermission (role, permission_id) â€” many-to-many
Seed permissions: create:post, edit:post, delete:post, manage:users
Assign permissions to roles
Create permission checker:
# Empty code structure placeholder
def require_permission(permission: str):
    async def permission_checker(current_user: User = Depends(get_current_user)):
        # Check if user's role has permission
        pass
    return permission_checker
Protect endpoints with specific permissions
Deliverable:

Granular permission system
Roles with assigned permissions
Permission-based route protection
Admin interface to manage permissions
Complete authorization flow
Why It Matters: Complex applications need fine-grained access control. Permission systems enable scalable authorization that doesn't require code changes for new rules.

If Behind: Just create a list of permissions as strings and check if user's role has the required permission.

Day 53-56: Multi-Module Application Project
Prerequisites: Days 43-52 complete

120-Minute Breakdown (4 Days):

Day 53: Set up project structure with 4 modules
Day 53: Configure shared authentication and database
Day 54: Implement users module (registration, login, profile)
Day 54: Implement auth middleware
Day 55: Implement products module (CRUD with permissions)
Day 55: Implement orders module (checkout, history)
Day 56: Implement admin module (user management, reports)
Day 56: Integration testing and documentation
Daily Exercise: Build day53-56/modular_ecommerce/:

app/
â”œâ”€â”€ main.py
â”œâ”€â”€ config.py
â”œâ”€â”€ database.py
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ models.py (User, RefreshToken, Permission)
â”‚   â”‚   â”œâ”€â”€ schemas.py (Login, Register, Token)
â”‚   â”‚   â”œâ”€â”€ service.py (authentication logic)
â”‚   â”‚   â”œâ”€â”€ dependencies.py (get_current_user, require_permission)
â”‚   â”‚   â””â”€â”€ router.py (register, login, refresh, logout)
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ models.py (UserProfile)
â”‚   â”‚   â”œâ”€â”€ service.py (profile management)
â”‚   â”‚   â””â”€â”€ router.py (GET/PUT /me, GET /users/{id})
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”œâ”€â”€ models.py (Product, Category, Review)
â”‚   â”‚   â”œâ”€â”€ service.py (business logic)
â”‚   â”‚   â””â”€â”€ router.py (CRUD with permissions)
â”‚   â”œâ”€â”€ orders/
â”‚   â”‚   â”œâ”€â”€ models.py (Order, OrderItem)
â”‚   â”‚   â”œâ”€â”€ service.py (checkout, stock management)
â”‚   â”‚   â””â”€â”€ router.py (create, list, track)
â”‚   â””â”€â”€ admin/
â”‚       â”œâ”€â”€ service.py (user management, analytics)
â”‚       â””â”€â”€ router.py (admin-only endpoints)
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ exceptions.py
â”‚   â”œâ”€â”€ pagination.py
â”‚   â””â”€â”€ responses.py
â””â”€â”€ tests/ (basic structure)
Features:

Auth Module:

Registration with email verification flag
Login with JWT + refresh token
Token refresh and revocation
Role and permission management
Users Module:

User profile CRUD
Public profile view
Profile picture URL field
User search (admin only)
Products Module:

CRUD with category support
Search and filtering
Review system
Stock tracking
Orders Module:

Cart to order conversion
Stock validation with transactions
Order history
Status tracking
Admin Module:

User management (ban, role changes)
Sales analytics
System monitoring endpoints
Deliverable:

Complete modular application
All modules independently functional
Shared authentication across modules
RBAC with permissions
Professional API documentation
Postman collection organized by modules
ER diagram showing all relationships
Weekly Deliverables Checklist (Week 7-8):

âœ… Modular architecture implemented
âœ… Environment-based configuration
âœ… Secure password hashing
âœ… JWT authentication with refresh tokens
âœ… OAuth2 compliance
âœ… Role-based access control
âœ… Granular permission system
âœ… Production-ready multi-module application
Why It Matters: This architecture mirrors real production applications. Modular design + authentication + authorization demonstrates senior-level backend engineering skills.

If Behind: Focus on Auth and Users modules with basic RBAC. Products and Orders can be simplified (no reviews, basic order creation).

